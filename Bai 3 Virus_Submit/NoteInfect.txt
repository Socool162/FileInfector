YÊU CẦU BÀI TẬP: VIRUS LÂY FILE (FILE INFECTOR)
=================================================

Viết một virus lây file (File Infector) đáp ứng các tiêu chí sau:

- Chỉ lây nhiễm file PE 32-bit (.exe, .dll) trong thư mục L:\test (để đảm bảo an toàn).
    + Không lây file .sys (driver hệ thống).
    + Không lây nhiễm cho chính nó hoặc các file đã bị lây từ trước.

- Khi một file PE bị nhiễm được chạy:
    + Đoạn mã lây lan phải được thực thi ngay.

- Để chứng minh đoạn mã virus đã chạy, bắt buộc thực hiện in ra console (printf) hoặc hiển thị MessageBox với nội dung tuỳ ý (ví dụ: “Infected...”).

- Sau khi hiển thị thông báo, tiếp tục lây nhiễm các file PE chưa nhiễm khác trong thư mục L:\test.

- Đảm bảo tại một thời điểm chỉ có duy nhất một tiến trình lây lan (dùng Mutex hoặc phương pháp khác).

- File sau khi bị nhiễm vẫn hoạt động bình thường, không crash hoặc lỗi.

- Ngôn ngữ: ASM

---

LỘ TRÌNH 8 BƯỚC HOÀN CHỈNH
===========================

🔄 Bước 1: Cấu trúc cơ bản + Mutex (Single Instance)
🔄 Bước 2: Hiển thị MessageBox thông báo nhiễm
🔄 Bước 3: Tìm file PE 32-bit (.exe và .dll) trong thư mục L:\test
🔄 Bước 4: Kiểm tra infection marker (tránh lây nhiễm trùng)
🔄 Bước 5: Cơ chế lây nhiễm PE file (thêm section/code)
    - Đây là phần cốt lõi và thú vị nhất.
    - Mục tiêu: Thêm một section mới (tên là `infected`) vào cuối file PE.
    - Chép code virus vào đó.
    - Tên `infected` giúp dễ nhận ra và cũng là "marker" để tránh lây nhiễm trùng (Đáp ứng Bước 4).
    - Sửa Entry Point của file PE để trỏ đến code virus.
🔄 Bước 6: Đảm bảo file gốc vẫn hoạt động bình thường, không crash hoặc lỗi
🔄 Bước 7: Không lây file hệ thống (.sys) và chính nó
🔄 Bước 8: Testing và hoàn thiện

---

LƯU Ý DEBUG: FindFirstFileA
==========================

Lỗi không nằm trong code, mà ở sự tương tác của 2 thứ:

1.  **Kết quả trả về của `FindFirstFileA`**: Nó trả về cả `.` và `..`.
2.  **Hàm `IsSystemFile` của bạn**: Hàm này tìm dấu chấm cuối cùng.
    - Đối với `.` và `..`, nó sẽ không tìm thấy phần mở rộng "sys" và sẽ trả về 0 (không phải file hệ thống).
    - Nếu code của bạn chỉ có `IsSystemFile`, nó sẽ cố gắng lây nhiễm cho `.` và `..`, gây ra lỗi.

===================================================================

🚀 ĐÁNH GIÁ LOGIC VIRUS LÂY NHIỄM FILE PE (ASSEMBLY)

(Việc review logic của nó cho người khác hiểu là một kỹ năng quan trọng.)

Bạn có thể chia bài review của mình thành 4 phần chính:
1.  **Khởi tạo (Entry Point `start`):** Virus chuẩn bị "vũ khí" (nạp API).
2.  **Vòng lặp chính (`infection_loop`):** Virus đi "săn mồi" (tìm file nạn nhân).
3.  **Cơ chế lây nhiễm (`InfectFile`):** Virus "tấn công" (chỉnh sửa file PE).
4.  **Payload (`virus_stub`):** Điều gì xảy ra khi "nạn nhân" bị thực thi.

Dưới đây là phân tích chi tiết từng bước:

---
### PHẦN 1: HÀM `start` - KHỞI TẠO VÀ NẠP API
---

Đây là nơi chương trình bắt đầu. Mục tiêu chính là lấy địa chỉ của các hàm Windows API mà virus cần dùng mà không cần khai báo `INCLUDELIB` (trừ `kernel32.lib`). Đây là một kỹ thuật phổ biến trong malware để tránh bị phát hiện qua các hàm `import`.

1.  **`call GetKernel32Base`:**
    * **Mục đích:** Lấy địa chỉ cơ sở (base address) của `kernel32.dll` trong bộ nhớ.
    * **Cách thức:** Không dùng `GetModuleHandle` mà truy cập thẳng vào **PEB** (Process Environment Block) qua `FS:[30h]`. Nó duyệt qua cấu trúc `PEB_LDR_DATA` để tìm `InMemoryOrderModuleList` và lấy base address của `kernel32.dll`.

2.  **`call FindGetProcAddress`:**
    * **Mục đích:** Tự phân tích cấu trúc PE (Export Table) của `kernel32.dll` để tìm địa chỉ của hàm `GetProcAddress`.
    * **Cách thức:** Duyệt Bảng Xuất (Export Table), tìm trong `AddressOfNames` chuỗi "GetProcAddress", dùng `AddressOfNameOrdinals` lấy chỉ số (ordinal), và cuối cùng dùng `AddressOfFunctions` để lấy RVA.

3.  **`invoke LoadAPI, ADDR ..._str` (Loạt hàm):**
    * **Mục đích:** Dùng `GetProcAddress` (vừa tìm được) để nạp địa chỉ của *tất cả* các hàm API khác.
    * **Ví dụ:** Gọi `GetProcAddress(hKernel32, "CreateFileA")` và lưu kết quả vào `pCreateFileA`.
    * **Kết quả:** Virus đã "vũ trang" đầy đủ với các con trỏ hàm (như `pCreateFileA`, `pWriteFile`, `pCreateMutexA`, v.v.).

4.  **`invoke CreateMutexA, ... "PEInfectorMutex"`:**
    * **Mục đích:** Đảm bảo chỉ có một tiến trình virus chạy tại một thời điểm (đáp ứng yêu cầu dùng Mutex).
    * **Cách thức:** Nó tạo một Mutex tên là "PEInfectorMutex". Nếu `GetLastError` trả về `ERROR_ALREADY_EXISTS` (nghĩa là đã có virus khác đang chạy), nó sẽ nhảy đến `@@exit` và tự kết thúc.

5.  **`invoke GetModuleFileNameA, ... ADDR self_path`:**
    * **Mục đích:** Lấy đường dẫn đầy đủ của chính file virus.
    * **Cách thức:** Lưu đường dẫn này vào `self_path` để `infection_loop` có thể so sánh và **tránh tự lây nhiễm chính mình**.

6.  **`invoke infection_loop, ADDR search_path`:**
    * **Mục đích:** Bắt đầu vòng lặp tìm kiếm và lây nhiễm chính.
    * **Cách thức:** Gọi hàm `infection_loop` và truyền vào chuỗi tìm kiếm là `"L:\test\*.*"`.

---
### PHẦN 2: HÀM `infection_loop` - VÒNG LẶP TÌM KIẾM
---

Hàm này chịu trách nhiệm quét thư mục `L:\test` và lọc ra các file "nạn nhân" tiềm năng.

1.  **`invoke FindFirstFileA`:** Bắt đầu tìm file đầu tiên khớp với `"L:\test\*.*"`.
    
2.  **`@@file_loop` (Bộ lọc):** Với mỗi file tìm được, nó thực hiện một loạt các kiểm tra "bộ lọc":
    * `invoke lstrcmpiA, ... dot_str` / `dotdot_str`: Bỏ qua `.` và `..`.
    * `test find_data.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY`: Bỏ qua nếu là thư mục.
    * `invoke IsSystemFile`: Gọi hàm con `IsSystemFile` để kiểm tra file có đuôi `.sys` không. Nếu có, bỏ qua.
    * `invoke lstrcpyA` / `lstrcatA`: Tạo đường dẫn đầy đủ của file (ví dụ: `L:\test\victim.exe`).
    * `invoke lstrcmpiA, ADDR self_path, ADDR target_path`: So sánh với đường dẫn của virus. Nếu trùng, bỏ qua (không tự lây nhiễm).
    
3.  **`invoke InfectFile, ADDR target_path`:**
    * **Đây là hành động chính!** Nếu một file vượt qua *tất cả* các bộ lọc trên, nó được coi là "nạn nhân". Hàm `InfectFile` được gọi để thực hiện lây nhiễm.
    
4.  **`invoke FindNextFileA`:** Tìm file tiếp theo và lặp lại `@@file_loop` cho đến khi hết file.
    
5.  **`invoke CloseHandle`:** Đóng handle tìm kiếm khi hoàn tất.

---
### PHẦN 3: HÀM `InfectFile` - CƠ CHẾ LÂY NHIỄM CỐT LÕI
---

Đây là trái tim của virus, nơi file nạn nhân bị "giải phẫu" và "cấy ghép".

1.  **Mở và Đọc file:**
    * `invoke CreateFileA`: Mở file nạn nhân với quyền `GENERIC_READ` và `GENERIC_WRITE`.
    * `invoke GetFileSize`: Lấy kích thước file.
    * `invoke VirtualAlloc`: Cấp phát một vùng bộ nhớ (buffer) đủ lớn.
    * `invoke ReadFile`: Đọc *toàn bộ* nội dung file nạn nhân vào buffer.

2.  **Kiểm tra tính hợp lệ của PE:**
    * Kiểm tra `word ptr [esi] != 'ZM'`: Có phải là file `MZ` không?
    * Kiểm tra `dword ptr [edi] != 00004550h`: Có phải là file `PE` không?
    * Kiểm tra `word ptr [edi + 4] != IMAGE_FILE_MACHINE_I386`: Có phải là file PE **32-bit** không?
    * Nếu bất kỳ kiểm tra nào thất bại, nhảy đến `@@free_and_fail` (đóng file, giải phóng bộ nhớ, và thoát).

3.  **Kiểm tra đã lây nhiễm chưa:**
    * `invoke CheckInfected, buffer`: Gọi hàm `CheckInfected`.
    * **Logic `CheckInfected`:** Hàm này duyệt qua tất cả các Section Header của file. Nó so sánh tên của từng section với chuỗi `".infect"`. Nếu tìm thấy, nó trả về `1`.
    * `.IF eax != 0`: Nếu `CheckInfected` trả về `1` (đã nhiễm), nhảy đến `@@free_and_fail` để bỏ qua.

4.  **Thêm Section mới (Hàm `AddInfectionSection`):**
    * **Đây là phần kỹ thuật phức tạp nhất.**
    * Nó tìm đến Section Header *cuối cùng* của file.
    * Nó tính toán `VirtualAddress` và `PointerToRawData` cho section mới, dựa trên section cuối cùng và các giá trị `SectionAlignment` / `FileAlignment`.
    * Nó ghi đè lên vùng trống ngay sau Section Header cuối cùng với một Section Header mới:
        * **Tên:** `".infect"`
        * **Kích thước:** `VirtualSize` = `virus_stub_size`, `SizeOfRawData` = `virus_stub_size` đã được làm tròn (align) theo `FileAlignment`.
        * **Đặc tính (Characteristics):** `0E0000020h` (Executable, Readable, Writable, Contains Code).
    * **Sửa đổi PE Header:**
        * Tăng `NumberOfSections` lên 1.
        * Cập nhật `SizeOfImage` (kích thước file trên bộ nhớ) để bao gồm cả section mới.
        * **Ghi đè Entry Point:** Nó lấy `VirtualAddress` của section `.infect` mới và ghi đè vào `AddressOfEntryPoint` của PE Header.
    * **Lưu OEP:** Nó lưu `AddressOfEntryPoint` *cũ* (Original Entry Point) vào biến `original_entry_point_val`.
    * **Lưu RVA Stub:** Nó lưu RVA của section mới vào `image_base_val` (để dùng cho stub, chống ASLR).
    * Hàm này trả về `PointerToRawData` (offset trên file) của section mới trong `EAX`.

5.  **Chép mã độc (Quay lại `InfectFile`):**
    * `mov ebx, eax`: `ebx` giờ chứa offset (vị trí) trên file để chép mã độc vào.
    * `rep movsb`: Chép toàn bộ `virus_stub_size` bytes từ `offset virus_stub` vào `buffer` tại vị trí `ebx`.

6.  **Patching Stub (Vá lỗi Stub):**
    * **Tại sao phải làm vậy?** `virus_stub` khi chạy bên trong file nạn nhân, nó không biết địa chỉ của `LoadLibraryA` hay `GetProcAddress`. Virus mẹ phải "mớm" các địa chỉ này cho nó.
    * `mov edi, buffer / add edi, ebx`: `edi` trỏ đến đầu `virus_stub` *bên trong buffer*.
    * `mov [edi + (offset pLoadLibraryA_stub...)]`: Ghi địa chỉ `pLoadLibraryA` vào biến `pLoadLibraryA_stub` của stub.
    * Tương tự, nó "vá" địa chỉ của `pGetProcAddress_stub`.
    * Nó "vá" `original_entry_point_stub` bằng giá trị `original_entry_point_val` (OEP của file host).
    * Nó "vá" `rva_stub` bằng giá trị `image_base_val` (RVA của section `.infect`).

7.  **Ghi file và Dọn dẹp:**
    * `invoke SetFilePointer, ... FILE_BEGIN`: Tua con trỏ file về đầu.
    * `invoke WriteFile, ... new_file_size`: Ghi *toàn bộ* buffer (đã bị chỉnh sửa) ra file, với kích thước mới.
    * `invoke CloseHandle` và `invoke VirtualFree`: Đóng file và giải phóng bộ nhớ.

---
### PHẦN 4: HÀM `virus_stub` - PAYLOAD (KHI FILE BỊ NHIỄM CHẠY)
---

Đây là đoạn code được chép vào section `.infect`. Khi người dùng chạy file bị nhiễm, PE Loader sẽ nhảy đến đây đầu tiên (vì chúng ta đã thay đổi Entry Point).

1.  **`call delta_offset` / `pop ebp`:**
    * **Mục đích:** Kỹ thuật Delta Offset để lấy EIP. Sau lệnh này, `ebp` sẽ trỏ đến địa chỉ cơ sở *thực tế* của `virus_stub` trong bộ nhớ.
    * Điều này rất quan trọng để tìm chuỗi và biến của stub, bất kể file host được nạp ở địa chỉ nào (chống ASLR).

2.  **Hiển thị `MessageBox`:**
    * `lea eax, [ebp + (offset stub_user32_dll...)]`: Lấy địa chỉ chuỗi "user32.dll" (dựa vào `ebp`).
    * `call DWORD PTR [ebp + (offset pLoadLibraryA_stub...)]`: Gọi `LoadLibraryA` (địa chỉ đã được "vá").
    * Tương tự, nó gọi `GetProcAddress` để lấy `MessageBoxA`.
    * `call eax`: Gọi `MessageBoxA` để hiển thị thông báo "This file has been infected!".

3.  **`@@restore_and_jump` (Trả lại quyền kiểm soát):**
    * **Mục đích:** Nhảy về OEP (Original Entry Point) để file host có thể chạy bình thường.
    * `sub ecx, [ebp + (offset rva_stub...)]`: `ImageBase_Thực_Tế = Địa_chỉ_stub - RVA_của_stub`. `ecx` giờ là ImageBase của file host.
    * `mov eax, [ebp + (offset original_entry_point_stub...)]`: `eax` = OEP (RVA) của file host (đã được "vá").
    * `add eax, ecx`: `Địa_chỉ_OEP_tuyệt_đối = ImageBase_Thực_Tế + OEP (RVA)`.
    * `jmp eax`: **Nhảy!** Chương trình gốc bắt đầu chạy mà không hề biết chuyện gì đã xảy ra.
    
---
## TÓM TẮT LUỒNG REVIEW
---

"Bắt đầu từ `start`, virus nạp động các API cần thiết bằng cách phân tích PEB và Export Table của `kernel32.dll`. Sau đó, nó tạo một Mutex để tránh chạy nhiều lần. Nó bắt đầu `infection_loop`, quét thư mục `L:\test`, lọc ra các file PE 32-bit chưa bị nhiễm và không phải là chính nó.

Với mỗi nạn nhân, nó gọi `InfectFile`, đọc file vào bộ nhớ, gọi `AddInfectionSection` để thêm một section `.infect` mới, và ghi đè `AddressOfEntryPoint` của file trỏ đến section này. Sau đó, nó chép `virus_stub` vào section mới, 'vá' các địa chỉ API cần thiết và OEP của host vào stub.

Khi file bị nhiễm được chạy, `virus_stub` thực thi trước. Nó dùng kỹ thuật delta offset để lấy EIP, hiển thị `MessageBox`, sau đó tính toán và nhảy về OEP, cho phép chương trình gốc tiếp tục chạy bình thường."

(Chúc bạn review code thành công!)

======================================================================

CHI TIẾT HƠN VỀ CÁC HÀM CHÍNH

======================================================================

### `GetKernel32Base`

1.  **`Mov Eax, FS:[30h] ; PEB`**
    * `FS` là một thanh ghi đoạn (segment register) trỏ đến **TEB** (Thread Environment Block).
    * Tại offset `+30h` bên trong TEB là một con trỏ trỏ đến **PEB** (Process Environment Block).
    * PEB chứa thông tin của *toàn bộ* tiến trình (process).
    * **Kết quả:** `EAX` giờ chứa địa chỉ của cấu trúc PEB.

2.  **`Mov Eax, DWORD PTR [Eax + 0Ch] ; PEB_LDR_DATA`**
    * `EAX` đang là con trỏ PEB. Tại offset `+0Ch` là một con trỏ trỏ đến `_PEB_LDR_DATA`.
    * Cấu trúc này quản lý thông tin về tất cả các module (.dll, .exe) đã được nạp.
    * **Kết quả:** `EAX` giờ chứa địa chỉ của `PEB_LDR_DATA`.

3.  **`Mov Eax, DWORD PTR [Eax + 14h] ; InMemoryOrderModuleList (Flink)`**
    * `EAX` đang là con trỏ `PEB_LDR_DATA`. Tại offset `+14h` là trường `InMemoryOrderModuleList`.
    * Đây là một `LIST_ENTRY` (danh sách liên kết kép) trỏ đến module đầu tiên được nạp (thường là file .exe).
    * Con trỏ này (`Flink`) trỏ đến thành viên `InMemoryOrderLinks` *bên trong* cấu trúc của module đó.
    * **Kết quả:** `EAX` trỏ đến `InMemoryOrderLinks` của module đầu tiên (file EXE).

4.  **`Mov Eax, DWORD PTR [Eax] ; Entry thứ 2 (ntdll.dll)`**
    * Vì `EAX` đang trỏ vào một `LIST_ENTRY` (của file EXE), `[Eax]` chính là lấy con trỏ `Flink` ("tiếp theo") của nó.
    * Con trỏ này trỏ đến `InMemoryOrderLinks` của module thứ hai, thường là `ntdll.dll`.
    * **Kết quả:** `EAX` trỏ đến `InMemoryOrderLinks` của `ntdll.dll`.

5.  **`Mov Eax, DWORD PTR [Eax] ; Entry thứ 3 (kernel32.dll)`**
    * Tương tự, `[Eax]` lại lấy `Flink` của `ntdll.dll`.
    * Con trỏ này trỏ đến `InMemoryOrderLinks` của module thứ ba, chính là `kernel32.dll`.
    * **Kết quả:** `EAX` trỏ đến `InMemoryOrderLinks` của `kernel32.dll`.

6.  **`Mov Eax, DWORD PTR [Eax + 10h] ; Base address của kernel32.dll`**
    * `EAX` đang trỏ đến `InMemoryOrderLinks` (tại `+0x08` của entry).
    * Lệnh `[Eax + 10h]` thực hiện phép toán: `(Địa chỉ đầu entry + 0x08) + 0x10h` = `Địa chỉ đầu entry + 0x18h`.
    * Vị trí `+0x18h` chính là nơi lưu con trỏ `DllBase` (Base Address).
    * **Kết quả:** `EAX` đọc giá trị tại `+0x18h` và giờ chứa địa chỉ cơ sở thực sự của `kernel32.dll`.

7.  **`Mov [hKernel32], Eax`**
    * Lưu địa chỉ cơ sở vừa tìm được vào biến `hKernel32` để sử dụng sau này.

---
### `FindGetProcAddress`
---

**Bước 1: Tìm Bảng Xuất (Export Address Table - EAT)**
1.  `mov ebx, [hKernel32]`: Nạp địa chỉ cơ sở của `kernel32.dll` vào `ebx`.
2.  `mov eax, [ebx + 3Ch]`: Lấy `e_lfanew` (offset đến PE Header) từ DOS Header.
3.  `add ebx, eax`: `ebx` bây giờ trỏ thẳng đến PE Header.
4.  `mov eax, [ebx + 78h]`: Lấy RVA của Bảng Xuất (EAT) từ Optional Header.
5.  `add edi, eax`: `edi =` (Base `kernel32`) + (RVA của EAT) = `VA` (địa chỉ tuyệt đối) của EAT. `edi` giờ trỏ vào EAT.

**Bước 2: Tìm danh sách tên hàm (Name List)**
1.  `mov ecx, [edi + 18h]`: Lấy `NumberOfNames` (tổng số hàm có tên) làm bộ đếm vòng lặp.
2.  `mov edx, [edi + 20h]`: Lấy RVA của mảng `AddressOfNames`.
3.  `add edx, [hKernel32]`: `edx` giờ trỏ đến VA của mảng `AddressOfNames`. Mảng này chứa các RVA trỏ đến chuỗi tên hàm.

**Bước 3: Vòng lặp tìm tên "GetProcAddress"**
(Vòng lặp duyệt ngược từ `NumberOfNames - 1` về `0`).
1.  `dec ecx`: `ecx` là *chỉ số* (index) của tên hàm.
2.  `mov esi, [edx + ecx*4]`: Lấy RVA của chuỗi tên hàm tại index `ecx`.
3.  `add esi, [hKernel32]`: `esi` giờ trỏ đến VA của chuỗi tên hàm (ví dụ: "CreateFileA").
4.  `cmp dword ptr [esi], 'PteG'`: So sánh 4 byte đầu với "GetP" (Vì Little Endian, 'PteG' đọc là 'GetP').
5.  `cmp dword ptr [esi+4], 'Acor'`: So sánh 4 byte tiếp theo với "rocA" (đọc là 'Acor').
6.  `cmp dword ptr [esi+8], 'erdd'`: So sánh 4 byte tiếp theo với "ddre" (đọc là 'erdd').
7.  (Ghép lại: "GetP" + "rocA" + "ddre" = "GetProcAddre").
8.  `jne @@find_loop`: Nếu sai, lặp tiếp.

**Bước 4: Lấy địa chỉ hàm (Function Address)**
(Nếu tìm thấy "GetProcAddress" tại index `ecx`)
1.  `mov edx, [edi + 24h]`: Lấy RVA của mảng `AddressOfNameOrdinals`.
2.  `add edx, [hKernel32]`: `edx` trỏ đến VA của mảng Ordinal.
3.  `movzx ecx, word ptr [edx + ecx*2]`: Dùng *chỉ số tên* (`ecx`) để tra cứu trong *mảng ordinal* (2-byte). `ecx` giờ chứa **giá trị ordinal** (số thứ tự) của hàm.
4.  `mov edx, [edi + 1Ch]`: Lấy RVA của mảng `AddressOfFunctions`.
5.  `add edx, [hKernel32]`: `edx` trỏ đến VA của mảng địa chỉ hàm.
6.  `mov eax, [edx + ecx*4]`: Dùng **giá trị ordinal** (`ecx` mới) làm *chỉ số* để tra cứu RVA của hàm.
7.  `add eax, [hKernel32]`: `eax =` (Base `kernel32`) + (RVA `GetProcAddress`) = **VA của `GetProcAddress`**.
8.  `mov [pGetProcAddress], eax`: Lưu "kho báu" vào biến `pGetProcAddress`.

(Tóm lại: Hàm này là một trình phân tích PE thu nhỏ, quét Bảng Xuất của `kernel32.dll` để tìm `GetProcAddress`, "chìa khóa mẹ" để nạp tất cả API khác.)

---
### `AddInfectionSection`
---

**Bước 1: Thu thập thông tin PE Header**
(Hàm nhận `file_buffer`, tìm đến PE Header và lưu vào `ebx`)
1.  `[ebx + 28h] -> original_entry_point_val`: Lưu lại **Entry Point gốc (OEP)** (là RVA) để trả lại quyền kiểm soát sau.
2.  `[ebx + 34h] -> image_base_val`: Lưu lại `ImageBase`.
3.  `[ebx + 38h] -> section_align`: Lấy `SectionAlignment` (bội số căn chỉnh trong *bộ nhớ*, vd: 1000h).
4.  `[ebx + 3Ch] -> file_align`: Lấy `FileAlignment` (bội số căn chỉnh trong *file*, vd: 200h).

**Bước 2: Tìm Section Header cuối cùng**
1.  `movzx ecx, word ptr [ebx + 6]`: Lấy `NumberOfSections`.
2.  `movzx edx, word ptr [ebx + 14h]`: Lấy `SizeOfOptionalHeader`.
3.  `lea edi, [ebx + 18h + edx]`: Tính địa chỉ của **Section Header đầu tiên**.
4.  `dec ecx ... imul eax, ecx ... add edi, eax`: `edi` giờ trỏ đến **Section Header cuối cùng**.

**Bước 3: Tính toán vị trí cho Section mới**
1.  **Tính `VirtualAddress` (RVA) mới (trong bộ nhớ):**
    * `mov eax, [edi + 0Ch]`: Lấy `VirtualAddress` của section cuối.
    * `add eax, [edi + 8]`: Cộng `VirtualSize` của nó.
    * `(Khối lệnh Align)`: "Làm tròn lên" (align up) `eax` theo `section_align`.
    * `mov edx, eax`: `edx` giờ chứa **RVA của section mới**.
    * `mov [image_base_val], edx`: **Quan trọng!** Lưu RVA này lại để `virus_stub` dùng (chống ASLR).
    
2.  **Tính `PointerToRawData` mới (trong file):**
    * `mov eax, [edi + 14h]`: Lấy `PointerToRawData` của section cuối.
    * `add eax, [edi + 10h]`: Cộng `SizeOfRawData` của nó.
    * `(Khối lệnh Align)`: Làm tròn `eax` lên theo `file_align`.
    * Kết quả `eax` chính là **offset trong file** nơi section mới sẽ bắt đầu.

**Bước 4: Ghi thông tin Section Header mới**
1.  `add edi, 28h`: Di chuyển `edi` đến chỗ trống *ngay sau* section header cuối.
2.  **Ghi thông tin:**
    * `rep movsb`: Chép 8 byte của chuỗi `.infect` vào trường `Name`.
    * `[edi + 8], virus_stub_size`: Ghi `VirtualSize` (kích thước thật).
    * `[edi + 0Ch], edx`: Ghi `VirtualAddress` (RVA mới).
    * `[edi + 10h], ecx`: Ghi `SizeOfRawData` (kích thước đã align theo file).
    * `[edi + 14h], eax`: Ghi `PointerToRawData` (offset file mới).
    * `[edi + 24h], 0E0000020h`: Ghi `Characteristics` (Code + Execute + Read + Write).

**Bước 5: Cập nhật PE Header chính**
1.  `inc word ptr [ebx + 6]`: Tăng `NumberOfSections` lên 1.
2.  **Cập nhật `SizeOfImage`:**
    * Lấy RVA section mới (`[edi + 0Ch]`) + `VirtualSize` (`[edi + 8]`).
    * Làm tròn (align) kết quả theo `section_align`.
    * `mov [ebx + 50h], ecx`: Ghi giá trị mới vào `SizeOfImage`.
3.  **Cập nhật `EntryPoint`:**
    * `mov edx, [edi + 0Ch]`: Lấy `VirtualAddress` (RVA) của section `.infect`.
    * `mov [ebx + 28h], edx`: **Đây là hành động lây nhiễm!** Ghi đè `AddressOfEntryPoint` trỏ vào RVA của section `.infect`.
    * (Lần sau file chạy, nó sẽ nhảy đến `virus_stub` thay vì code gốc).

**Bước 6: Trả về**
1.  `mov eax, [edi + 14h]`: Nạp `PointerToRawData` (offset file) vào `eax`.
2.  `ret`: Trở về. `InfectFile` sẽ nhận được giá trị này và biết chép `virus_stub` vào đâu.
    
---
### `virus_stub`
---

**Bước 1: Kỹ thuật Delta Offset (Tìm chính mình)**
1.  `call delta_offset`: Đẩy địa chỉ của `delta_offset:` vào stack và nhảy đến đó.
2.  `delta_offset:`
3.  `pop ebp`: Lấy địa chỉ của `delta_offset:` vào `ebp`. `ebp` giờ chứa địa chỉ bộ nhớ *thực tế* của nhãn này.
4.  `sub ebp, (offset delta_offset - offset virus_stub)`: Trình biên dịch tự tính khoảng cách (compile-time) từ `virus_stub` đến `delta_offset`.
5.  **Kết quả:** `ebp =` (Địa chỉ `delta_offset:`) - (Khoảng cách) = **Địa chỉ đầu của `virus_stub`**.
6.  **Tại sao?** `ebp` giờ là "mỏ neo" để truy cập các biến/chuỗi của stub, bất kể file host bị nạp ở đâu.

**Bước 2: Thực thi Payload (Hiện MessageBox)**
1.  `lea eax, [ebp + (offset stub_user32_dll - ...)]`: Tính địa chỉ tuyệt đối của chuỗi "user32.dll" (dựa vào "mỏ neo" `ebp`).
2.  `push eax`: Đẩy con trỏ chuỗi vào stack.
3.  `call DWORD PTR [ebp + (offset pLoadLibraryA_stub - ...)]`:
    * Lấy giá trị từ biến `pLoadLibraryA_stub` (dựa vào `ebp`).
    * Giá trị này đã được virus mẹ "vá" (patch) vào lúc lây nhiễm.
    * Về cơ bản là `call [địa_chỉ_LoadLibraryA_thực_sự]`.
4.  `test eax, eax / jz @@restore_and_jump`: Kiểm tra `LoadLibraryA` thành công không. Nếu thất bại, nhảy đến bước 3.
5.  **Tương tự:** Dùng `GetProcAddress` (đã được vá) để tìm `MessageBoxA`.
6.  `call eax` (Gọi MessageBox): `push` các tham số và gọi `MessageBoxA`.
7.  **Kết quả:** Hộp thoại "This file has been infected!" hiện lên. Payload hoàn thành.

**Bước 3: Trả lại quyền kiểm soát (Nhảy về OEP)**
1.  `@@restore_and_jump:`
2.  `mov ecx, ebp`: `ecx` = Địa chỉ cơ sở *tuyệt đối* của `virus_stub`.
3.  `sub ecx, [ebp + (offset rva_stub - ...)]`:
    * `ecx =` (Địa chỉ tuyệt đối) - (RVA của section `.infect` - đã được vá).
    * Đây là phép toán: `ImageBase = Địa_chỉ_tuyệt_đối - RVA`.
    * **Kết quả:** `ecx` giờ chứa **ImageBase ngẫu nhiên** (do ASLR) của file host.
4.  `mov eax, [ebp + (offset original_entry_point_stub - ...)]`:
    * Lấy giá trị từ `original_entry_point_stub` (biến này đã được vá OEP *gốc* (RVA) của file host).
    * `eax` giờ chứa RVA của OEP.
5.  `add eax, ecx`:
    * Phép toán: `eax = (OEP RVA) + (ImageBase ngẫu nhiên)`
    * **Kết quả:** `eax` giờ chứa địa chỉ *tuyệt đối* của OEP.
6.  `jmp eax`: **Nhảy!** Chương trình nhảy chính xác đến nơi nó đáng lẽ phải bắt đầu, và chạy bình thường.




END!