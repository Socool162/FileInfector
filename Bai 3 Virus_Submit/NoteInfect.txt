Y√äU C·∫¶U B√ÄI T·∫¨P: VIRUS L√ÇY FILE (FILE INFECTOR)
=================================================

Vi·∫øt m·ªôt virus l√¢y file (File Infector) ƒë√°p ·ª©ng c√°c ti√™u ch√≠ sau:

- Ch·ªâ l√¢y nhi·ªÖm file PE 32-bit (.exe, .dll) trong th∆∞ m·ª•c L:\test (ƒë·ªÉ ƒë·∫£m b·∫£o an to√†n).
    + Kh√¥ng l√¢y file .sys (driver h·ªá th·ªëng).
    + Kh√¥ng l√¢y nhi·ªÖm cho ch√≠nh n√≥ ho·∫∑c c√°c file ƒë√£ b·ªã l√¢y t·ª´ tr∆∞·ªõc.

- Khi m·ªôt file PE b·ªã nhi·ªÖm ƒë∆∞·ª£c ch·∫°y:
    + ƒêo·∫°n m√£ l√¢y lan ph·∫£i ƒë∆∞·ª£c th·ª±c thi ngay.

- ƒê·ªÉ ch·ª©ng minh ƒëo·∫°n m√£ virus ƒë√£ ch·∫°y, b·∫Øt bu·ªôc th·ª±c hi·ªán in ra console (printf) ho·∫∑c hi·ªÉn th·ªã MessageBox v·ªõi n·ªôi dung tu·ª≥ √Ω (v√≠ d·ª•: ‚ÄúInfected...‚Äù).

- Sau khi hi·ªÉn th·ªã th√¥ng b√°o, ti·∫øp t·ª•c l√¢y nhi·ªÖm c√°c file PE ch∆∞a nhi·ªÖm kh√°c trong th∆∞ m·ª•c L:\test.

- ƒê·∫£m b·∫£o t·∫°i m·ªôt th·ªùi ƒëi·ªÉm ch·ªâ c√≥ duy nh·∫•t m·ªôt ti·∫øn tr√¨nh l√¢y lan (d√πng Mutex ho·∫∑c ph∆∞∆°ng ph√°p kh√°c).

- File sau khi b·ªã nhi·ªÖm v·∫´n ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng, kh√¥ng crash ho·∫∑c l·ªói.

- Ng√¥n ng·ªØ: ASM

---

L·ªò TR√åNH 8 B∆Ø·ªöC HO√ÄN CH·ªàNH
===========================

üîÑ B∆∞·ªõc 1: C·∫•u tr√∫c c∆° b·∫£n + Mutex (Single Instance)
üîÑ B∆∞·ªõc 2: Hi·ªÉn th·ªã MessageBox th√¥ng b√°o nhi·ªÖm
üîÑ B∆∞·ªõc 3: T√¨m file PE 32-bit (.exe v√† .dll) trong th∆∞ m·ª•c L:\test
üîÑ B∆∞·ªõc 4: Ki·ªÉm tra infection marker (tr√°nh l√¢y nhi·ªÖm tr√πng)
üîÑ B∆∞·ªõc 5: C∆° ch·∫ø l√¢y nhi·ªÖm PE file (th√™m section/code)
    - ƒê√¢y l√† ph·∫ßn c·ªët l√µi v√† th√∫ v·ªã nh·∫•t.
    - M·ª•c ti√™u: Th√™m m·ªôt section m·ªõi (t√™n l√† `infected`) v√†o cu·ªëi file PE.
    - Ch√©p code virus v√†o ƒë√≥.
    - T√™n `infected` gi√∫p d·ªÖ nh·∫≠n ra v√† c≈©ng l√† "marker" ƒë·ªÉ tr√°nh l√¢y nhi·ªÖm tr√πng (ƒê√°p ·ª©ng B∆∞·ªõc 4).
    - S·ª≠a Entry Point c·ªßa file PE ƒë·ªÉ tr·ªè ƒë·∫øn code virus.
üîÑ B∆∞·ªõc 6: ƒê·∫£m b·∫£o file g·ªëc v·∫´n ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng, kh√¥ng crash ho·∫∑c l·ªói
üîÑ B∆∞·ªõc 7: Kh√¥ng l√¢y file h·ªá th·ªëng (.sys) v√† ch√≠nh n√≥
üîÑ B∆∞·ªõc 8: Testing v√† ho√†n thi·ªán

---

L∆ØU √ù DEBUG: FindFirstFileA
==========================

L·ªói kh√¥ng n·∫±m trong code, m√† ·ªü s·ª± t∆∞∆°ng t√°c c·ªßa 2 th·ª©:

1.  **K·∫øt qu·∫£ tr·∫£ v·ªÅ c·ªßa `FindFirstFileA`**: N√≥ tr·∫£ v·ªÅ c·∫£ `.` v√† `..`.
2.  **H√†m `IsSystemFile` c·ªßa b·∫°n**: H√†m n√†y t√¨m d·∫•u ch·∫•m cu·ªëi c√πng.
    - ƒê·ªëi v·ªõi `.` v√† `..`, n√≥ s·∫Ω kh√¥ng t√¨m th·∫•y ph·∫ßn m·ªü r·ªông "sys" v√† s·∫Ω tr·∫£ v·ªÅ 0 (kh√¥ng ph·∫£i file h·ªá th·ªëng).
    - N·∫øu code c·ªßa b·∫°n ch·ªâ c√≥ `IsSystemFile`, n√≥ s·∫Ω c·ªë g·∫Øng l√¢y nhi·ªÖm cho `.` v√† `..`, g√¢y ra l·ªói.

===================================================================

üöÄ ƒê√ÅNH GI√Å LOGIC VIRUS L√ÇY NHI·ªÑM FILE PE (ASSEMBLY)

(Vi·ªác review logic c·ªßa n√≥ cho ng∆∞·ªùi kh√°c hi·ªÉu l√† m·ªôt k·ªπ nƒÉng quan tr·ªçng.)

B·∫°n c√≥ th·ªÉ chia b√†i review c·ªßa m√¨nh th√†nh 4 ph·∫ßn ch√≠nh:
1.  **Kh·ªüi t·∫°o (Entry Point `start`):** Virus chu·∫©n b·ªã "v≈© kh√≠" (n·∫°p API).
2.  **V√≤ng l·∫∑p ch√≠nh (`infection_loop`):** Virus ƒëi "sƒÉn m·ªìi" (t√¨m file n·∫°n nh√¢n).
3.  **C∆° ch·∫ø l√¢y nhi·ªÖm (`InfectFile`):** Virus "t·∫•n c√¥ng" (ch·ªânh s·ª≠a file PE).
4.  **Payload (`virus_stub`):** ƒêi·ªÅu g√¨ x·∫£y ra khi "n·∫°n nh√¢n" b·ªã th·ª±c thi.

D∆∞·ªõi ƒë√¢y l√† ph√¢n t√≠ch chi ti·∫øt t·ª´ng b∆∞·ªõc:

---
### PH·∫¶N 1: H√ÄM `start` - KH·ªûI T·∫†O V√Ä N·∫†P API
---

ƒê√¢y l√† n∆°i ch∆∞∆°ng tr√¨nh b·∫Øt ƒë·∫ßu. M·ª•c ti√™u ch√≠nh l√† l·∫•y ƒë·ªãa ch·ªâ c·ªßa c√°c h√†m Windows API m√† virus c·∫ßn d√πng m√† kh√¥ng c·∫ßn khai b√°o `INCLUDELIB` (tr·ª´ `kernel32.lib`). ƒê√¢y l√† m·ªôt k·ªπ thu·∫≠t ph·ªï bi·∫øn trong malware ƒë·ªÉ tr√°nh b·ªã ph√°t hi·ªán qua c√°c h√†m `import`.

1.  **`call GetKernel32Base`:**
    * **M·ª•c ƒë√≠ch:** L·∫•y ƒë·ªãa ch·ªâ c∆° s·ªü (base address) c·ªßa `kernel32.dll` trong b·ªô nh·ªõ.
    * **C√°ch th·ª©c:** Kh√¥ng d√πng `GetModuleHandle` m√† truy c·∫≠p th·∫≥ng v√†o **PEB** (Process Environment Block) qua `FS:[30h]`. N√≥ duy·ªát qua c·∫•u tr√∫c `PEB_LDR_DATA` ƒë·ªÉ t√¨m `InMemoryOrderModuleList` v√† l·∫•y base address c·ªßa `kernel32.dll`.

2.  **`call FindGetProcAddress`:**
    * **M·ª•c ƒë√≠ch:** T·ª± ph√¢n t√≠ch c·∫•u tr√∫c PE (Export Table) c·ªßa `kernel32.dll` ƒë·ªÉ t√¨m ƒë·ªãa ch·ªâ c·ªßa h√†m `GetProcAddress`.
    * **C√°ch th·ª©c:** Duy·ªát B·∫£ng Xu·∫•t (Export Table), t√¨m trong `AddressOfNames` chu·ªói "GetProcAddress", d√πng `AddressOfNameOrdinals` l·∫•y ch·ªâ s·ªë (ordinal), v√† cu·ªëi c√πng d√πng `AddressOfFunctions` ƒë·ªÉ l·∫•y RVA.

3.  **`invoke LoadAPI, ADDR ..._str` (Lo·∫°t h√†m):**
    * **M·ª•c ƒë√≠ch:** D√πng `GetProcAddress` (v·ª´a t√¨m ƒë∆∞·ª£c) ƒë·ªÉ n·∫°p ƒë·ªãa ch·ªâ c·ªßa *t·∫•t c·∫£* c√°c h√†m API kh√°c.
    * **V√≠ d·ª•:** G·ªçi `GetProcAddress(hKernel32, "CreateFileA")` v√† l∆∞u k·∫øt qu·∫£ v√†o `pCreateFileA`.
    * **K·∫øt qu·∫£:** Virus ƒë√£ "v≈© trang" ƒë·∫ßy ƒë·ªß v·ªõi c√°c con tr·ªè h√†m (nh∆∞ `pCreateFileA`, `pWriteFile`, `pCreateMutexA`, v.v.).

4.  **`invoke CreateMutexA, ... "PEInfectorMutex"`:**
    * **M·ª•c ƒë√≠ch:** ƒê·∫£m b·∫£o ch·ªâ c√≥ m·ªôt ti·∫øn tr√¨nh virus ch·∫°y t·∫°i m·ªôt th·ªùi ƒëi·ªÉm (ƒë√°p ·ª©ng y√™u c·∫ßu d√πng Mutex).
    * **C√°ch th·ª©c:** N√≥ t·∫°o m·ªôt Mutex t√™n l√† "PEInfectorMutex". N·∫øu `GetLastError` tr·∫£ v·ªÅ `ERROR_ALREADY_EXISTS` (nghƒ©a l√† ƒë√£ c√≥ virus kh√°c ƒëang ch·∫°y), n√≥ s·∫Ω nh·∫£y ƒë·∫øn `@@exit` v√† t·ª± k·∫øt th√∫c.

5.  **`invoke GetModuleFileNameA, ... ADDR self_path`:**
    * **M·ª•c ƒë√≠ch:** L·∫•y ƒë∆∞·ªùng d·∫´n ƒë·∫ßy ƒë·ªß c·ªßa ch√≠nh file virus.
    * **C√°ch th·ª©c:** L∆∞u ƒë∆∞·ªùng d·∫´n n√†y v√†o `self_path` ƒë·ªÉ `infection_loop` c√≥ th·ªÉ so s√°nh v√† **tr√°nh t·ª± l√¢y nhi·ªÖm ch√≠nh m√¨nh**.

6.  **`invoke infection_loop, ADDR search_path`:**
    * **M·ª•c ƒë√≠ch:** B·∫Øt ƒë·∫ßu v√≤ng l·∫∑p t√¨m ki·∫øm v√† l√¢y nhi·ªÖm ch√≠nh.
    * **C√°ch th·ª©c:** G·ªçi h√†m `infection_loop` v√† truy·ªÅn v√†o chu·ªói t√¨m ki·∫øm l√† `"L:\test\*.*"`.

---
### PH·∫¶N 2: H√ÄM `infection_loop` - V√íNG L·∫∂P T√åM KI·∫æM
---

H√†m n√†y ch·ªãu tr√°ch nhi·ªám qu√©t th∆∞ m·ª•c `L:\test` v√† l·ªçc ra c√°c file "n·∫°n nh√¢n" ti·ªÅm nƒÉng.

1.  **`invoke FindFirstFileA`:** B·∫Øt ƒë·∫ßu t√¨m file ƒë·∫ßu ti√™n kh·ªõp v·ªõi `"L:\test\*.*"`.
    
2.  **`@@file_loop` (B·ªô l·ªçc):** V·ªõi m·ªói file t√¨m ƒë∆∞·ª£c, n√≥ th·ª±c hi·ªán m·ªôt lo·∫°t c√°c ki·ªÉm tra "b·ªô l·ªçc":
    * `invoke lstrcmpiA, ... dot_str` / `dotdot_str`: B·ªè qua `.` v√† `..`.
    * `test find_data.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY`: B·ªè qua n·∫øu l√† th∆∞ m·ª•c.
    * `invoke IsSystemFile`: G·ªçi h√†m con `IsSystemFile` ƒë·ªÉ ki·ªÉm tra file c√≥ ƒëu√¥i `.sys` kh√¥ng. N·∫øu c√≥, b·ªè qua.
    * `invoke lstrcpyA` / `lstrcatA`: T·∫°o ƒë∆∞·ªùng d·∫´n ƒë·∫ßy ƒë·ªß c·ªßa file (v√≠ d·ª•: `L:\test\victim.exe`).
    * `invoke lstrcmpiA, ADDR self_path, ADDR target_path`: So s√°nh v·ªõi ƒë∆∞·ªùng d·∫´n c·ªßa virus. N·∫øu tr√πng, b·ªè qua (kh√¥ng t·ª± l√¢y nhi·ªÖm).
    
3.  **`invoke InfectFile, ADDR target_path`:**
    * **ƒê√¢y l√† h√†nh ƒë·ªông ch√≠nh!** N·∫øu m·ªôt file v∆∞·ª£t qua *t·∫•t c·∫£* c√°c b·ªô l·ªçc tr√™n, n√≥ ƒë∆∞·ª£c coi l√† "n·∫°n nh√¢n". H√†m `InfectFile` ƒë∆∞·ª£c g·ªçi ƒë·ªÉ th·ª±c hi·ªán l√¢y nhi·ªÖm.
    
4.  **`invoke FindNextFileA`:** T√¨m file ti·∫øp theo v√† l·∫∑p l·∫°i `@@file_loop` cho ƒë·∫øn khi h·∫øt file.
    
5.  **`invoke CloseHandle`:** ƒê√≥ng handle t√¨m ki·∫øm khi ho√†n t·∫•t.

---
### PH·∫¶N 3: H√ÄM `InfectFile` - C∆† CH·∫æ L√ÇY NHI·ªÑM C·ªêT L√ïI
---

ƒê√¢y l√† tr√°i tim c·ªßa virus, n∆°i file n·∫°n nh√¢n b·ªã "gi·∫£i ph·∫´u" v√† "c·∫•y gh√©p".

1.  **M·ªü v√† ƒê·ªçc file:**
    * `invoke CreateFileA`: M·ªü file n·∫°n nh√¢n v·ªõi quy·ªÅn `GENERIC_READ` v√† `GENERIC_WRITE`.
    * `invoke GetFileSize`: L·∫•y k√≠ch th∆∞·ªõc file.
    * `invoke VirtualAlloc`: C·∫•p ph√°t m·ªôt v√πng b·ªô nh·ªõ (buffer) ƒë·ªß l·ªõn.
    * `invoke ReadFile`: ƒê·ªçc *to√†n b·ªô* n·ªôi dung file n·∫°n nh√¢n v√†o buffer.

2.  **Ki·ªÉm tra t√≠nh h·ª£p l·ªá c·ªßa PE:**
    * Ki·ªÉm tra `word ptr [esi] != 'ZM'`: C√≥ ph·∫£i l√† file `MZ` kh√¥ng?
    * Ki·ªÉm tra `dword ptr [edi] != 00004550h`: C√≥ ph·∫£i l√† file `PE` kh√¥ng?
    * Ki·ªÉm tra `word ptr [edi + 4] != IMAGE_FILE_MACHINE_I386`: C√≥ ph·∫£i l√† file PE **32-bit** kh√¥ng?
    * N·∫øu b·∫•t k·ª≥ ki·ªÉm tra n√†o th·∫•t b·∫°i, nh·∫£y ƒë·∫øn `@@free_and_fail` (ƒë√≥ng file, gi·∫£i ph√≥ng b·ªô nh·ªõ, v√† tho√°t).

3.  **Ki·ªÉm tra ƒë√£ l√¢y nhi·ªÖm ch∆∞a:**
    * `invoke CheckInfected, buffer`: G·ªçi h√†m `CheckInfected`.
    * **Logic `CheckInfected`:** H√†m n√†y duy·ªát qua t·∫•t c·∫£ c√°c Section Header c·ªßa file. N√≥ so s√°nh t√™n c·ªßa t·ª´ng section v·ªõi chu·ªói `".infect"`. N·∫øu t√¨m th·∫•y, n√≥ tr·∫£ v·ªÅ `1`.
    * `.IF eax != 0`: N·∫øu `CheckInfected` tr·∫£ v·ªÅ `1` (ƒë√£ nhi·ªÖm), nh·∫£y ƒë·∫øn `@@free_and_fail` ƒë·ªÉ b·ªè qua.

4.  **Th√™m Section m·ªõi (H√†m `AddInfectionSection`):**
    * **ƒê√¢y l√† ph·∫ßn k·ªπ thu·∫≠t ph·ª©c t·∫°p nh·∫•t.**
    * N√≥ t√¨m ƒë·∫øn Section Header *cu·ªëi c√πng* c·ªßa file.
    * N√≥ t√≠nh to√°n `VirtualAddress` v√† `PointerToRawData` cho section m·ªõi, d·ª±a tr√™n section cu·ªëi c√πng v√† c√°c gi√° tr·ªã `SectionAlignment` / `FileAlignment`.
    * N√≥ ghi ƒë√® l√™n v√πng tr·ªëng ngay sau Section Header cu·ªëi c√πng v·ªõi m·ªôt Section Header m·ªõi:
        * **T√™n:** `".infect"`
        * **K√≠ch th∆∞·ªõc:** `VirtualSize` = `virus_stub_size`, `SizeOfRawData` = `virus_stub_size` ƒë√£ ƒë∆∞·ª£c l√†m tr√≤n (align) theo `FileAlignment`.
        * **ƒê·∫∑c t√≠nh (Characteristics):** `0E0000020h` (Executable, Readable, Writable, Contains Code).
    * **S·ª≠a ƒë·ªïi PE Header:**
        * TƒÉng `NumberOfSections` l√™n 1.
        * C·∫≠p nh·∫≠t `SizeOfImage` (k√≠ch th∆∞·ªõc file tr√™n b·ªô nh·ªõ) ƒë·ªÉ bao g·ªìm c·∫£ section m·ªõi.
        * **Ghi ƒë√® Entry Point:** N√≥ l·∫•y `VirtualAddress` c·ªßa section `.infect` m·ªõi v√† ghi ƒë√® v√†o `AddressOfEntryPoint` c·ªßa PE Header.
    * **L∆∞u OEP:** N√≥ l∆∞u `AddressOfEntryPoint` *c≈©* (Original Entry Point) v√†o bi·∫øn `original_entry_point_val`.
    * **L∆∞u RVA Stub:** N√≥ l∆∞u RVA c·ªßa section m·ªõi v√†o `image_base_val` (ƒë·ªÉ d√πng cho stub, ch·ªëng ASLR).
    * H√†m n√†y tr·∫£ v·ªÅ `PointerToRawData` (offset tr√™n file) c·ªßa section m·ªõi trong `EAX`.

5.  **Ch√©p m√£ ƒë·ªôc (Quay l·∫°i `InfectFile`):**
    * `mov ebx, eax`: `ebx` gi·ªù ch·ª©a offset (v·ªã tr√≠) tr√™n file ƒë·ªÉ ch√©p m√£ ƒë·ªôc v√†o.
    * `rep movsb`: Ch√©p to√†n b·ªô `virus_stub_size` bytes t·ª´ `offset virus_stub` v√†o `buffer` t·∫°i v·ªã tr√≠ `ebx`.

6.  **Patching Stub (V√° l·ªói Stub):**
    * **T·∫°i sao ph·∫£i l√†m v·∫≠y?** `virus_stub` khi ch·∫°y b√™n trong file n·∫°n nh√¢n, n√≥ kh√¥ng bi·∫øt ƒë·ªãa ch·ªâ c·ªßa `LoadLibraryA` hay `GetProcAddress`. Virus m·∫π ph·∫£i "m·ªõm" c√°c ƒë·ªãa ch·ªâ n√†y cho n√≥.
    * `mov edi, buffer / add edi, ebx`: `edi` tr·ªè ƒë·∫øn ƒë·∫ßu `virus_stub` *b√™n trong buffer*.
    * `mov [edi + (offset pLoadLibraryA_stub...)]`: Ghi ƒë·ªãa ch·ªâ `pLoadLibraryA` v√†o bi·∫øn `pLoadLibraryA_stub` c·ªßa stub.
    * T∆∞∆°ng t·ª±, n√≥ "v√°" ƒë·ªãa ch·ªâ c·ªßa `pGetProcAddress_stub`.
    * N√≥ "v√°" `original_entry_point_stub` b·∫±ng gi√° tr·ªã `original_entry_point_val` (OEP c·ªßa file host).
    * N√≥ "v√°" `rva_stub` b·∫±ng gi√° tr·ªã `image_base_val` (RVA c·ªßa section `.infect`).

7.  **Ghi file v√† D·ªçn d·∫πp:**
    * `invoke SetFilePointer, ... FILE_BEGIN`: Tua con tr·ªè file v·ªÅ ƒë·∫ßu.
    * `invoke WriteFile, ... new_file_size`: Ghi *to√†n b·ªô* buffer (ƒë√£ b·ªã ch·ªânh s·ª≠a) ra file, v·ªõi k√≠ch th∆∞·ªõc m·ªõi.
    * `invoke CloseHandle` v√† `invoke VirtualFree`: ƒê√≥ng file v√† gi·∫£i ph√≥ng b·ªô nh·ªõ.

---
### PH·∫¶N 4: H√ÄM `virus_stub` - PAYLOAD (KHI FILE B·ªä NHI·ªÑM CH·∫†Y)
---

ƒê√¢y l√† ƒëo·∫°n code ƒë∆∞·ª£c ch√©p v√†o section `.infect`. Khi ng∆∞·ªùi d√πng ch·∫°y file b·ªã nhi·ªÖm, PE Loader s·∫Ω nh·∫£y ƒë·∫øn ƒë√¢y ƒë·∫ßu ti√™n (v√¨ ch√∫ng ta ƒë√£ thay ƒë·ªïi Entry Point).

1.  **`call delta_offset` / `pop ebp`:**
    * **M·ª•c ƒë√≠ch:** K·ªπ thu·∫≠t Delta Offset ƒë·ªÉ l·∫•y EIP. Sau l·ªánh n√†y, `ebp` s·∫Ω tr·ªè ƒë·∫øn ƒë·ªãa ch·ªâ c∆° s·ªü *th·ª±c t·∫ø* c·ªßa `virus_stub` trong b·ªô nh·ªõ.
    * ƒêi·ªÅu n√†y r·∫•t quan tr·ªçng ƒë·ªÉ t√¨m chu·ªói v√† bi·∫øn c·ªßa stub, b·∫•t k·ªÉ file host ƒë∆∞·ª£c n·∫°p ·ªü ƒë·ªãa ch·ªâ n√†o (ch·ªëng ASLR).

2.  **Hi·ªÉn th·ªã `MessageBox`:**
    * `lea eax, [ebp + (offset stub_user32_dll...)]`: L·∫•y ƒë·ªãa ch·ªâ chu·ªói "user32.dll" (d·ª±a v√†o `ebp`).
    * `call DWORD PTR [ebp + (offset pLoadLibraryA_stub...)]`: G·ªçi `LoadLibraryA` (ƒë·ªãa ch·ªâ ƒë√£ ƒë∆∞·ª£c "v√°").
    * T∆∞∆°ng t·ª±, n√≥ g·ªçi `GetProcAddress` ƒë·ªÉ l·∫•y `MessageBoxA`.
    * `call eax`: G·ªçi `MessageBoxA` ƒë·ªÉ hi·ªÉn th·ªã th√¥ng b√°o "This file has been infected!".

3.  **`@@restore_and_jump` (Tr·∫£ l·∫°i quy·ªÅn ki·ªÉm so√°t):**
    * **M·ª•c ƒë√≠ch:** Nh·∫£y v·ªÅ OEP (Original Entry Point) ƒë·ªÉ file host c√≥ th·ªÉ ch·∫°y b√¨nh th∆∞·ªùng.
    * `sub ecx, [ebp + (offset rva_stub...)]`: `ImageBase_Th·ª±c_T·∫ø = ƒê·ªãa_ch·ªâ_stub - RVA_c·ªßa_stub`. `ecx` gi·ªù l√† ImageBase c·ªßa file host.
    * `mov eax, [ebp + (offset original_entry_point_stub...)]`: `eax` = OEP (RVA) c·ªßa file host (ƒë√£ ƒë∆∞·ª£c "v√°").
    * `add eax, ecx`: `ƒê·ªãa_ch·ªâ_OEP_tuy·ªát_ƒë·ªëi = ImageBase_Th·ª±c_T·∫ø + OEP (RVA)`.
    * `jmp eax`: **Nh·∫£y!** Ch∆∞∆°ng tr√¨nh g·ªëc b·∫Øt ƒë·∫ßu ch·∫°y m√† kh√¥ng h·ªÅ bi·∫øt chuy·ªán g√¨ ƒë√£ x·∫£y ra.
    
---
## T√ìM T·∫ÆT LU·ªíNG REVIEW
---

"B·∫Øt ƒë·∫ßu t·ª´ `start`, virus n·∫°p ƒë·ªông c√°c API c·∫ßn thi·∫øt b·∫±ng c√°ch ph√¢n t√≠ch PEB v√† Export Table c·ªßa `kernel32.dll`. Sau ƒë√≥, n√≥ t·∫°o m·ªôt Mutex ƒë·ªÉ tr√°nh ch·∫°y nhi·ªÅu l·∫ßn. N√≥ b·∫Øt ƒë·∫ßu `infection_loop`, qu√©t th∆∞ m·ª•c `L:\test`, l·ªçc ra c√°c file PE 32-bit ch∆∞a b·ªã nhi·ªÖm v√† kh√¥ng ph·∫£i l√† ch√≠nh n√≥.

V·ªõi m·ªói n·∫°n nh√¢n, n√≥ g·ªçi `InfectFile`, ƒë·ªçc file v√†o b·ªô nh·ªõ, g·ªçi `AddInfectionSection` ƒë·ªÉ th√™m m·ªôt section `.infect` m·ªõi, v√† ghi ƒë√® `AddressOfEntryPoint` c·ªßa file tr·ªè ƒë·∫øn section n√†y. Sau ƒë√≥, n√≥ ch√©p `virus_stub` v√†o section m·ªõi, 'v√°' c√°c ƒë·ªãa ch·ªâ API c·∫ßn thi·∫øt v√† OEP c·ªßa host v√†o stub.

Khi file b·ªã nhi·ªÖm ƒë∆∞·ª£c ch·∫°y, `virus_stub` th·ª±c thi tr∆∞·ªõc. N√≥ d√πng k·ªπ thu·∫≠t delta offset ƒë·ªÉ l·∫•y EIP, hi·ªÉn th·ªã `MessageBox`, sau ƒë√≥ t√≠nh to√°n v√† nh·∫£y v·ªÅ OEP, cho ph√©p ch∆∞∆°ng tr√¨nh g·ªëc ti·∫øp t·ª•c ch·∫°y b√¨nh th∆∞·ªùng."

(Ch√∫c b·∫°n review code th√†nh c√¥ng!)

======================================================================

CHI TI·∫æT H∆†N V·ªÄ C√ÅC H√ÄM CH√çNH

======================================================================

### `GetKernel32Base`

1.  **`Mov Eax, FS:[30h] ; PEB`**
    * `FS` l√† m·ªôt thanh ghi ƒëo·∫°n (segment register) tr·ªè ƒë·∫øn **TEB** (Thread Environment Block).
    * T·∫°i offset `+30h` b√™n trong TEB l√† m·ªôt con tr·ªè tr·ªè ƒë·∫øn **PEB** (Process Environment Block).
    * PEB ch·ª©a th√¥ng tin c·ªßa *to√†n b·ªô* ti·∫øn tr√¨nh (process).
    * **K·∫øt qu·∫£:** `EAX` gi·ªù ch·ª©a ƒë·ªãa ch·ªâ c·ªßa c·∫•u tr√∫c PEB.

2.  **`Mov Eax, DWORD PTR [Eax + 0Ch] ; PEB_LDR_DATA`**
    * `EAX` ƒëang l√† con tr·ªè PEB. T·∫°i offset `+0Ch` l√† m·ªôt con tr·ªè tr·ªè ƒë·∫øn `_PEB_LDR_DATA`.
    * C·∫•u tr√∫c n√†y qu·∫£n l√Ω th√¥ng tin v·ªÅ t·∫•t c·∫£ c√°c module (.dll, .exe) ƒë√£ ƒë∆∞·ª£c n·∫°p.
    * **K·∫øt qu·∫£:** `EAX` gi·ªù ch·ª©a ƒë·ªãa ch·ªâ c·ªßa `PEB_LDR_DATA`.

3.  **`Mov Eax, DWORD PTR [Eax + 14h] ; InMemoryOrderModuleList (Flink)`**
    * `EAX` ƒëang l√† con tr·ªè `PEB_LDR_DATA`. T·∫°i offset `+14h` l√† tr∆∞·ªùng `InMemoryOrderModuleList`.
    * ƒê√¢y l√† m·ªôt `LIST_ENTRY` (danh s√°ch li√™n k·∫øt k√©p) tr·ªè ƒë·∫øn module ƒë·∫ßu ti√™n ƒë∆∞·ª£c n·∫°p (th∆∞·ªùng l√† file .exe).
    * Con tr·ªè n√†y (`Flink`) tr·ªè ƒë·∫øn th√†nh vi√™n `InMemoryOrderLinks` *b√™n trong* c·∫•u tr√∫c c·ªßa module ƒë√≥.
    * **K·∫øt qu·∫£:** `EAX` tr·ªè ƒë·∫øn `InMemoryOrderLinks` c·ªßa module ƒë·∫ßu ti√™n (file EXE).

4.  **`Mov Eax, DWORD PTR [Eax] ; Entry th·ª© 2 (ntdll.dll)`**
    * V√¨ `EAX` ƒëang tr·ªè v√†o m·ªôt `LIST_ENTRY` (c·ªßa file EXE), `[Eax]` ch√≠nh l√† l·∫•y con tr·ªè `Flink` ("ti·∫øp theo") c·ªßa n√≥.
    * Con tr·ªè n√†y tr·ªè ƒë·∫øn `InMemoryOrderLinks` c·ªßa module th·ª© hai, th∆∞·ªùng l√† `ntdll.dll`.
    * **K·∫øt qu·∫£:** `EAX` tr·ªè ƒë·∫øn `InMemoryOrderLinks` c·ªßa `ntdll.dll`.

5.  **`Mov Eax, DWORD PTR [Eax] ; Entry th·ª© 3 (kernel32.dll)`**
    * T∆∞∆°ng t·ª±, `[Eax]` l·∫°i l·∫•y `Flink` c·ªßa `ntdll.dll`.
    * Con tr·ªè n√†y tr·ªè ƒë·∫øn `InMemoryOrderLinks` c·ªßa module th·ª© ba, ch√≠nh l√† `kernel32.dll`.
    * **K·∫øt qu·∫£:** `EAX` tr·ªè ƒë·∫øn `InMemoryOrderLinks` c·ªßa `kernel32.dll`.

6.  **`Mov Eax, DWORD PTR [Eax + 10h] ; Base address c·ªßa kernel32.dll`**
    * `EAX` ƒëang tr·ªè ƒë·∫øn `InMemoryOrderLinks` (t·∫°i `+0x08` c·ªßa entry).
    * L·ªánh `[Eax + 10h]` th·ª±c hi·ªán ph√©p to√°n: `(ƒê·ªãa ch·ªâ ƒë·∫ßu entry + 0x08) + 0x10h` = `ƒê·ªãa ch·ªâ ƒë·∫ßu entry + 0x18h`.
    * V·ªã tr√≠ `+0x18h` ch√≠nh l√† n∆°i l∆∞u con tr·ªè `DllBase` (Base Address).
    * **K·∫øt qu·∫£:** `EAX` ƒë·ªçc gi√° tr·ªã t·∫°i `+0x18h` v√† gi·ªù ch·ª©a ƒë·ªãa ch·ªâ c∆° s·ªü th·ª±c s·ª± c·ªßa `kernel32.dll`.

7.  **`Mov [hKernel32], Eax`**
    * L∆∞u ƒë·ªãa ch·ªâ c∆° s·ªü v·ª´a t√¨m ƒë∆∞·ª£c v√†o bi·∫øn `hKernel32` ƒë·ªÉ s·ª≠ d·ª•ng sau n√†y.

---
### `FindGetProcAddress`
---

**B∆∞·ªõc 1: T√¨m B·∫£ng Xu·∫•t (Export Address Table - EAT)**
1.  `mov ebx, [hKernel32]`: N·∫°p ƒë·ªãa ch·ªâ c∆° s·ªü c·ªßa `kernel32.dll` v√†o `ebx`.
2.  `mov eax, [ebx + 3Ch]`: L·∫•y `e_lfanew` (offset ƒë·∫øn PE Header) t·ª´ DOS Header.
3.  `add ebx, eax`: `ebx` b√¢y gi·ªù tr·ªè th·∫≥ng ƒë·∫øn PE Header.
4.  `mov eax, [ebx + 78h]`: L·∫•y RVA c·ªßa B·∫£ng Xu·∫•t (EAT) t·ª´ Optional Header.
5.  `add edi, eax`: `edi =` (Base `kernel32`) + (RVA c·ªßa EAT) = `VA` (ƒë·ªãa ch·ªâ tuy·ªát ƒë·ªëi) c·ªßa EAT. `edi` gi·ªù tr·ªè v√†o EAT.

**B∆∞·ªõc 2: T√¨m danh s√°ch t√™n h√†m (Name List)**
1.  `mov ecx, [edi + 18h]`: L·∫•y `NumberOfNames` (t·ªïng s·ªë h√†m c√≥ t√™n) l√†m b·ªô ƒë·∫øm v√≤ng l·∫∑p.
2.  `mov edx, [edi + 20h]`: L·∫•y RVA c·ªßa m·∫£ng `AddressOfNames`.
3.  `add edx, [hKernel32]`: `edx` gi·ªù tr·ªè ƒë·∫øn VA c·ªßa m·∫£ng `AddressOfNames`. M·∫£ng n√†y ch·ª©a c√°c RVA tr·ªè ƒë·∫øn chu·ªói t√™n h√†m.

**B∆∞·ªõc 3: V√≤ng l·∫∑p t√¨m t√™n "GetProcAddress"**
(V√≤ng l·∫∑p duy·ªát ng∆∞·ª£c t·ª´ `NumberOfNames - 1` v·ªÅ `0`).
1.  `dec ecx`: `ecx` l√† *ch·ªâ s·ªë* (index) c·ªßa t√™n h√†m.
2.  `mov esi, [edx + ecx*4]`: L·∫•y RVA c·ªßa chu·ªói t√™n h√†m t·∫°i index `ecx`.
3.  `add esi, [hKernel32]`: `esi` gi·ªù tr·ªè ƒë·∫øn VA c·ªßa chu·ªói t√™n h√†m (v√≠ d·ª•: "CreateFileA").
4.  `cmp dword ptr [esi], 'PteG'`: So s√°nh 4 byte ƒë·∫ßu v·ªõi "GetP" (V√¨ Little Endian, 'PteG' ƒë·ªçc l√† 'GetP').
5.  `cmp dword ptr [esi+4], 'Acor'`: So s√°nh 4 byte ti·∫øp theo v·ªõi "rocA" (ƒë·ªçc l√† 'Acor').
6.  `cmp dword ptr [esi+8], 'erdd'`: So s√°nh 4 byte ti·∫øp theo v·ªõi "ddre" (ƒë·ªçc l√† 'erdd').
7.  (Gh√©p l·∫°i: "GetP" + "rocA" + "ddre" = "GetProcAddre").
8.  `jne @@find_loop`: N·∫øu sai, l·∫∑p ti·∫øp.

**B∆∞·ªõc 4: L·∫•y ƒë·ªãa ch·ªâ h√†m (Function Address)**
(N·∫øu t√¨m th·∫•y "GetProcAddress" t·∫°i index `ecx`)
1.  `mov edx, [edi + 24h]`: L·∫•y RVA c·ªßa m·∫£ng `AddressOfNameOrdinals`.
2.  `add edx, [hKernel32]`: `edx` tr·ªè ƒë·∫øn VA c·ªßa m·∫£ng Ordinal.
3.  `movzx ecx, word ptr [edx + ecx*2]`: D√πng *ch·ªâ s·ªë t√™n* (`ecx`) ƒë·ªÉ tra c·ª©u trong *m·∫£ng ordinal* (2-byte). `ecx` gi·ªù ch·ª©a **gi√° tr·ªã ordinal** (s·ªë th·ª© t·ª±) c·ªßa h√†m.
4.  `mov edx, [edi + 1Ch]`: L·∫•y RVA c·ªßa m·∫£ng `AddressOfFunctions`.
5.  `add edx, [hKernel32]`: `edx` tr·ªè ƒë·∫øn VA c·ªßa m·∫£ng ƒë·ªãa ch·ªâ h√†m.
6.  `mov eax, [edx + ecx*4]`: D√πng **gi√° tr·ªã ordinal** (`ecx` m·ªõi) l√†m *ch·ªâ s·ªë* ƒë·ªÉ tra c·ª©u RVA c·ªßa h√†m.
7.  `add eax, [hKernel32]`: `eax =` (Base `kernel32`) + (RVA `GetProcAddress`) = **VA c·ªßa `GetProcAddress`**.
8.  `mov [pGetProcAddress], eax`: L∆∞u "kho b√°u" v√†o bi·∫øn `pGetProcAddress`.

(T√≥m l·∫°i: H√†m n√†y l√† m·ªôt tr√¨nh ph√¢n t√≠ch PE thu nh·ªè, qu√©t B·∫£ng Xu·∫•t c·ªßa `kernel32.dll` ƒë·ªÉ t√¨m `GetProcAddress`, "ch√¨a kh√≥a m·∫π" ƒë·ªÉ n·∫°p t·∫•t c·∫£ API kh√°c.)

---
### `AddInfectionSection`
---

**B∆∞·ªõc 1: Thu th·∫≠p th√¥ng tin PE Header**
(H√†m nh·∫≠n `file_buffer`, t√¨m ƒë·∫øn PE Header v√† l∆∞u v√†o `ebx`)
1.  `[ebx + 28h] -> original_entry_point_val`: L∆∞u l·∫°i **Entry Point g·ªëc (OEP)** (l√† RVA) ƒë·ªÉ tr·∫£ l·∫°i quy·ªÅn ki·ªÉm so√°t sau.
2.  `[ebx + 34h] -> image_base_val`: L∆∞u l·∫°i `ImageBase`.
3.  `[ebx + 38h] -> section_align`: L·∫•y `SectionAlignment` (b·ªôi s·ªë cƒÉn ch·ªânh trong *b·ªô nh·ªõ*, vd: 1000h).
4.  `[ebx + 3Ch] -> file_align`: L·∫•y `FileAlignment` (b·ªôi s·ªë cƒÉn ch·ªânh trong *file*, vd: 200h).

**B∆∞·ªõc 2: T√¨m Section Header cu·ªëi c√πng**
1.  `movzx ecx, word ptr [ebx + 6]`: L·∫•y `NumberOfSections`.
2.  `movzx edx, word ptr [ebx + 14h]`: L·∫•y `SizeOfOptionalHeader`.
3.  `lea edi, [ebx + 18h + edx]`: T√≠nh ƒë·ªãa ch·ªâ c·ªßa **Section Header ƒë·∫ßu ti√™n**.
4.  `dec ecx ... imul eax, ecx ... add edi, eax`: `edi` gi·ªù tr·ªè ƒë·∫øn **Section Header cu·ªëi c√πng**.

**B∆∞·ªõc 3: T√≠nh to√°n v·ªã tr√≠ cho Section m·ªõi**
1.  **T√≠nh `VirtualAddress` (RVA) m·ªõi (trong b·ªô nh·ªõ):**
    * `mov eax, [edi + 0Ch]`: L·∫•y `VirtualAddress` c·ªßa section cu·ªëi.
    * `add eax, [edi + 8]`: C·ªông `VirtualSize` c·ªßa n√≥.
    * `(Kh·ªëi l·ªánh Align)`: "L√†m tr√≤n l√™n" (align up) `eax` theo `section_align`.
    * `mov edx, eax`: `edx` gi·ªù ch·ª©a **RVA c·ªßa section m·ªõi**.
    * `mov [image_base_val], edx`: **Quan tr·ªçng!** L∆∞u RVA n√†y l·∫°i ƒë·ªÉ `virus_stub` d√πng (ch·ªëng ASLR).
    
2.  **T√≠nh `PointerToRawData` m·ªõi (trong file):**
    * `mov eax, [edi + 14h]`: L·∫•y `PointerToRawData` c·ªßa section cu·ªëi.
    * `add eax, [edi + 10h]`: C·ªông `SizeOfRawData` c·ªßa n√≥.
    * `(Kh·ªëi l·ªánh Align)`: L√†m tr√≤n `eax` l√™n theo `file_align`.
    * K·∫øt qu·∫£ `eax` ch√≠nh l√† **offset trong file** n∆°i section m·ªõi s·∫Ω b·∫Øt ƒë·∫ßu.

**B∆∞·ªõc 4: Ghi th√¥ng tin Section Header m·ªõi**
1.  `add edi, 28h`: Di chuy·ªÉn `edi` ƒë·∫øn ch·ªó tr·ªëng *ngay sau* section header cu·ªëi.
2.  **Ghi th√¥ng tin:**
    * `rep movsb`: Ch√©p 8 byte c·ªßa chu·ªói `.infect` v√†o tr∆∞·ªùng `Name`.
    * `[edi + 8], virus_stub_size`: Ghi `VirtualSize` (k√≠ch th∆∞·ªõc th·∫≠t).
    * `[edi + 0Ch], edx`: Ghi `VirtualAddress` (RVA m·ªõi).
    * `[edi + 10h], ecx`: Ghi `SizeOfRawData` (k√≠ch th∆∞·ªõc ƒë√£ align theo file).
    * `[edi + 14h], eax`: Ghi `PointerToRawData` (offset file m·ªõi).
    * `[edi + 24h], 0E0000020h`: Ghi `Characteristics` (Code + Execute + Read + Write).

**B∆∞·ªõc 5: C·∫≠p nh·∫≠t PE Header ch√≠nh**
1.  `inc word ptr [ebx + 6]`: TƒÉng `NumberOfSections` l√™n 1.
2.  **C·∫≠p nh·∫≠t `SizeOfImage`:**
    * L·∫•y RVA section m·ªõi (`[edi + 0Ch]`) + `VirtualSize` (`[edi + 8]`).
    * L√†m tr√≤n (align) k·∫øt qu·∫£ theo `section_align`.
    * `mov [ebx + 50h], ecx`: Ghi gi√° tr·ªã m·ªõi v√†o `SizeOfImage`.
3.  **C·∫≠p nh·∫≠t `EntryPoint`:**
    * `mov edx, [edi + 0Ch]`: L·∫•y `VirtualAddress` (RVA) c·ªßa section `.infect`.
    * `mov [ebx + 28h], edx`: **ƒê√¢y l√† h√†nh ƒë·ªông l√¢y nhi·ªÖm!** Ghi ƒë√® `AddressOfEntryPoint` tr·ªè v√†o RVA c·ªßa section `.infect`.
    * (L·∫ßn sau file ch·∫°y, n√≥ s·∫Ω nh·∫£y ƒë·∫øn `virus_stub` thay v√¨ code g·ªëc).

**B∆∞·ªõc 6: Tr·∫£ v·ªÅ**
1.  `mov eax, [edi + 14h]`: N·∫°p `PointerToRawData` (offset file) v√†o `eax`.
2.  `ret`: Tr·ªü v·ªÅ. `InfectFile` s·∫Ω nh·∫≠n ƒë∆∞·ª£c gi√° tr·ªã n√†y v√† bi·∫øt ch√©p `virus_stub` v√†o ƒë√¢u.
    
---
### `virus_stub`
---

**B∆∞·ªõc 1: K·ªπ thu·∫≠t Delta Offset (T√¨m ch√≠nh m√¨nh)**
1.  `call delta_offset`: ƒê·∫©y ƒë·ªãa ch·ªâ c·ªßa `delta_offset:` v√†o stack v√† nh·∫£y ƒë·∫øn ƒë√≥.
2.  `delta_offset:`
3.  `pop ebp`: L·∫•y ƒë·ªãa ch·ªâ c·ªßa `delta_offset:` v√†o `ebp`. `ebp` gi·ªù ch·ª©a ƒë·ªãa ch·ªâ b·ªô nh·ªõ *th·ª±c t·∫ø* c·ªßa nh√£n n√†y.
4.  `sub ebp, (offset delta_offset - offset virus_stub)`: Tr√¨nh bi√™n d·ªãch t·ª± t√≠nh kho·∫£ng c√°ch (compile-time) t·ª´ `virus_stub` ƒë·∫øn `delta_offset`.
5.  **K·∫øt qu·∫£:** `ebp =` (ƒê·ªãa ch·ªâ `delta_offset:`) - (Kho·∫£ng c√°ch) = **ƒê·ªãa ch·ªâ ƒë·∫ßu c·ªßa `virus_stub`**.
6.  **T·∫°i sao?** `ebp` gi·ªù l√† "m·ªè neo" ƒë·ªÉ truy c·∫≠p c√°c bi·∫øn/chu·ªói c·ªßa stub, b·∫•t k·ªÉ file host b·ªã n·∫°p ·ªü ƒë√¢u.

**B∆∞·ªõc 2: Th·ª±c thi Payload (Hi·ªán MessageBox)**
1.  `lea eax, [ebp + (offset stub_user32_dll - ...)]`: T√≠nh ƒë·ªãa ch·ªâ tuy·ªát ƒë·ªëi c·ªßa chu·ªói "user32.dll" (d·ª±a v√†o "m·ªè neo" `ebp`).
2.  `push eax`: ƒê·∫©y con tr·ªè chu·ªói v√†o stack.
3.  `call DWORD PTR [ebp + (offset pLoadLibraryA_stub - ...)]`:
    * L·∫•y gi√° tr·ªã t·ª´ bi·∫øn `pLoadLibraryA_stub` (d·ª±a v√†o `ebp`).
    * Gi√° tr·ªã n√†y ƒë√£ ƒë∆∞·ª£c virus m·∫π "v√°" (patch) v√†o l√∫c l√¢y nhi·ªÖm.
    * V·ªÅ c∆° b·∫£n l√† `call [ƒë·ªãa_ch·ªâ_LoadLibraryA_th·ª±c_s·ª±]`.
4.  `test eax, eax / jz @@restore_and_jump`: Ki·ªÉm tra `LoadLibraryA` th√†nh c√¥ng kh√¥ng. N·∫øu th·∫•t b·∫°i, nh·∫£y ƒë·∫øn b∆∞·ªõc 3.
5.  **T∆∞∆°ng t·ª±:** D√πng `GetProcAddress` (ƒë√£ ƒë∆∞·ª£c v√°) ƒë·ªÉ t√¨m `MessageBoxA`.
6.  `call eax` (G·ªçi MessageBox): `push` c√°c tham s·ªë v√† g·ªçi `MessageBoxA`.
7.  **K·∫øt qu·∫£:** H·ªôp tho·∫°i "This file has been infected!" hi·ªán l√™n. Payload ho√†n th√†nh.

**B∆∞·ªõc 3: Tr·∫£ l·∫°i quy·ªÅn ki·ªÉm so√°t (Nh·∫£y v·ªÅ OEP)**
1.  `@@restore_and_jump:`
2.  `mov ecx, ebp`: `ecx` = ƒê·ªãa ch·ªâ c∆° s·ªü *tuy·ªát ƒë·ªëi* c·ªßa `virus_stub`.
3.  `sub ecx, [ebp + (offset rva_stub - ...)]`:
    * `ecx =` (ƒê·ªãa ch·ªâ tuy·ªát ƒë·ªëi) - (RVA c·ªßa section `.infect` - ƒë√£ ƒë∆∞·ª£c v√°).
    * ƒê√¢y l√† ph√©p to√°n: `ImageBase = ƒê·ªãa_ch·ªâ_tuy·ªát_ƒë·ªëi - RVA`.
    * **K·∫øt qu·∫£:** `ecx` gi·ªù ch·ª©a **ImageBase ng·∫´u nhi√™n** (do ASLR) c·ªßa file host.
4.  `mov eax, [ebp + (offset original_entry_point_stub - ...)]`:
    * L·∫•y gi√° tr·ªã t·ª´ `original_entry_point_stub` (bi·∫øn n√†y ƒë√£ ƒë∆∞·ª£c v√° OEP *g·ªëc* (RVA) c·ªßa file host).
    * `eax` gi·ªù ch·ª©a RVA c·ªßa OEP.
5.  `add eax, ecx`:
    * Ph√©p to√°n: `eax = (OEP RVA) + (ImageBase ng·∫´u nhi√™n)`
    * **K·∫øt qu·∫£:** `eax` gi·ªù ch·ª©a ƒë·ªãa ch·ªâ *tuy·ªát ƒë·ªëi* c·ªßa OEP.
6.  `jmp eax`: **Nh·∫£y!** Ch∆∞∆°ng tr√¨nh nh·∫£y ch√≠nh x√°c ƒë·∫øn n∆°i n√≥ ƒë√°ng l·∫Ω ph·∫£i b·∫Øt ƒë·∫ßu, v√† ch·∫°y b√¨nh th∆∞·ªùng.




END!